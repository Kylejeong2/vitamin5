Each process will maintain its own file descriptor table (a list in the PCB) that will map small integers (file descriptors) to open file handles. File descriptors 0 and 1 are reserved for standard input/output and are not allocated by open(). On an initial open call, the kernel will allocate the next available file descriptor (starting from 2) and store the returned struct file* in the table. Validity is checked by ensuring the fd is within the table’s bounds and that the corresponding entry is non-NULL (indicating an open file). Attempts to use an fd not in the current process’s table or already closed will be rejected (e.g. returning -1). The file system itself is not thread-safe in Pintos, so we will use a global lock to synchronize file operations and prevent concurrent syscalls from corrupting file data structures. → fixed sized array.
We will introduce a child process control block (PCB entry) that tracks each child’s status, exit code, and a synchronization primitive for wait. This structure is allocated in kernel memory when a child process is created and is accessible to both parent and child in kernel mode. It contains the child’s process ID (pid), exit code, exit flag to check if the child has exited, and a semaphore. The parent process keeps a list of the child-PCB entries to track children. When a parent calls wait(pid), we search the list to check if the PID is a valid child–if it’s not, we return -1. If it’s a valid child and that child is still running, the parent will block on the child’s semaphore until the child’s exit occurs. If the child has already terminated (its exit code is available), the parent retrieves the exit status. We also then mark that child as reaped (to prevent duplicate waits). When the child calls exit(status), it will fill its exit code into the shared PCB entry and signal the waiting parent (the semaphore) to wake it up. The child will then proceed with termination. → manual cleanup with reference counting strategy and lock around the logic for the parent and the child
struct for exit states
Proper cleanup is crucial to avoid leaks. Each process will close all of its open file descriptors upon exit, releasing those file and memory resources. For parent-child structures, we implement zombie process semantics. If a child exits before its parent has called wait, the child’s PCB entry (containing exit code and sync primitives) cannot be freed immediately – it remains in the parent’s child list as a “zombie” record so that the parent can collect the exit code later. In this case, the child’s actual thread and other resources are freed (the OS thread structure, etc.), but we keep the small PCB entry around. If the parent calls wait, we free the child’s PCB entry after returning the exit code. If the parent terminates without waiting, then any remaining child PCB entries for children that have already exited are freed at that point (since no future wait will occur). If a parent exits while a child is still running, we will mark the child’s PCB so that when the child eventually exits it knows no parent will wait, the child can then free its PCB entry immediately upon termination. In all cases, all resources of a process are eventually freed (the struct thread, open files, and any allocated PCB/exit-code memory) whether or not the parent waited.
The kernel must validate all pointers and data passed by user programs to system calls, to prevent crashes or security breaches. We will adopt the strategy of checking the user page table before dereferencing any user pointer. In practice, this means for each pointer argument (including strings and buffers), the kernel will verify that every page of the intended memory region is both below the user-kernel address boundary and mapped into the process’s address space. We can implement helper functions (e.g. validate_user_buffer(ptr, length) and validate_user_string(str)) that iterate over the buffer’s address range page by page and use Pintos page table functions (from userprog/pagedir.c and threads/vaddr.h) to ensure each page is present and is a user page. For example, we will use is_user_vaddr(addr) (to check address < PHYS_BASE) and pagedir_get_page(pagedir, addr) to confirm the address is mapped to a frame. Only if all checks pass do we proceed to read or write the user memory. If any pointer is invalid or lies outside the process’s memory, the kernel will handle it as a memory access violation, the offending process will be terminated and an exit status of -1 will be recorded. We will also ensure to release any resources (locks, etc.) acquired during the syscall before terminating the process in such a case.
